package com.fleshgrinder.gradle.distribution.kit

import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.plugins.ExtensionAware
import org.gradle.api.provider.MapProperty
import org.gradle.api.provider.Property
import org.gradle.api.provider.Provider
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.Internal

/**
 * Configuration properties for resolving, compiling, and assembling of the custom Gradle distribution.
 */
public abstract class GradleDistributionKitExtension : ExtensionAware {
    /**
     * Specifies the artifact pattern (Ivy syntax) for the artifacts found in the [repository][repositoryUrl]. Defaults
     * to [DEFAULT_ARTIFACT_PATTERN].
     */
    @get:Input
    public abstract val artifactPattern: Property<String>

    /**
     * Specifies the directory where all the files generated by the tasks are stored to. Defaults to a directory named
     * [DEFAULT_BUILD_DIRECTORY_NAME] in the project's build directory.
     *
     * @see CompileGradleDistribution.destinationDirectory
     */
    @get:Internal("Exposed via destinationDirectory in CompileGradleDistribution")
    public abstract val buildDirectory: DirectoryProperty

    /**
     * Specifies dynamic Gradle properties that should be included in the `gradle.properties` of the custom Gradle
     * distribution that is about to be built. The properties specified here are going to overwrite any properties that
     * are sourced from the [Gradle properties files][CompileGradleDistribution.gradleProperties]. Defaults to an
     * empty map.
     *
     * This is not a [MapProperty] because it is impossible to define a [MapProperty] with a value type of `Any?`. It
     * leads to overload resolution ambiguity whenever a [Provider] is passed to [MapProperty.put], and an exception is
     * thrown whenever `null` is passed to [MapProperty.put]. To add injury to insult it also fails when configuration
     * caching is enabled and any value in the [MapProperty] is a [Provider]. Using a standard Java map fixes all those
     * issues, but it is not possible anymore to use the advanced capabilities of Gradle's [Property] class (e.g.
     * [Property.disallowUnsafeRead], [Property.finalizeValueOnRead]).
     */
    @get:Input
    public val gradleProperties: MutableMap<String, Any?> = mutableMapOf()

    /**
     * Specifies whether the `gradle.properties` file of the current project should be included, or not. Setting this
     * to `true` will include the properties from the `gradle.properties` file of the current project, and the
     * `gradle.properties` of the root project, if this project is a subproject. Defaults to `false`.
     */
    @get:Input
    public abstract val includeProjectGradleProperties: Property<Boolean>

    /**
     * Specifies whether pre-releases in the [repository][repositoryUrl] should be ignored (`false`), or not (`true`).
     * Defaults to `false` (pre-releases are ignored).
     */
    @get:Input
    public abstract val preReleases: Property<Boolean>

    /**
     * Specifies the URL of the repository from where the available Gradle distributions are going to be resolved from.
     * Defaults to [DEFAULT_REPOSITORY_URL].
     */
    @get:Input
    public abstract val repositoryUrl: Property<String>

    /**
     * Specifies the source directories from where the [init script files][CompileGradleDistribution.initScripts]
     * and [Gradle properties files][CompileGradleDistribution.gradleProperties] are collected from. Defaults to all
     * source directories of the [DEFAULT_SOURCE_SET_NAME].
     */
    @get:Internal("Exposed via initScriptFiles and gradlePropertyFiles in CompileGradleDistribution")
    public abstract val sourceDirectories: ConfigurableFileCollection

    /**
     * Specifies the name of the custom Gradle distribution vendor.
     */
    @get:Input
    public abstract val vendor: Property<String>
}
